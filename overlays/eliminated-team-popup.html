<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PUBG Team Elimination Overlay</title>
    <link rel="stylesheet" href="./styles.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
        
        body {
            background-color: transparent; 
            font-family: 'Roboto', sans-serif;
            color: white;
            margin: 0;
            padding: 0;
            font-weight: bold;
        }

        #elim-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -45%);
            opacity: 0;
            display: none;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            flex-direction: row;
            align-items: stretch;
            min-width: 400px;
            max-width: 800px;
            min-height: 120px;
            padding: 10px;
            transition: opacity 0.6s ease, transform 0.6s ease;
        }

        #elim-popup.show {
            display: flex;
            opacity: 1;
            transform: translate(-50%, -50%);
        }

        .column {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        .left-column {
            width: 100px;
            position: relative;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            background-color: var(--main-color, #ffffff);
        }

        .center-column {
            flex: 1;
            text-align: center;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            background-color: var(--accent-color, #333333);
            min-width: 150px;
        }

        .right-column {
            width: 100px;
        }

        #elim-placement { /* <-- Correct ID from your original file */
            position: absolute;
            top: 5px;
            left: 5px;
            font-size: 1.2em;
            font-weight: 700;
            color: var(--main-color, #ffffff);
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 8px;
            border-radius: 5px;
        }

        #elim-logo { /* <-- Correct ID from your original file */
            width: 100%;
            height: 80px;
            object-fit: contain;
            margin-top: 20px;
        }

        #elim-name { /* <-- Correct ID from your original file */
            font-size: 1.8em;
            font-weight: 700;
            text-transform: uppercase;
            color: rgba(0, 0, 0, 0.8);
            margin-bottom: 5px;
            white-space: normal;
            word-wrap: break-word;
            max-width: 100%;
            line-height: 1.2;
        }

        .elim-status {
            font-size: 1.8em;
            color: var(--main-color, #ffffff);
            text-transform: uppercase;
            margin-top: 5px;
        }

        #elim-kills { /* <-- Correct ID from your original file */
            font-size: 3.5em;
            font-weight: 700;
            color: var(--main-color, #ffffff);
            margin-bottom: 5px;
        }

        .kills-label {
            font-size: 1.8em;
            text-transform: uppercase;
        }

        /* @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -40%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }

        @keyframes fadeOut {
            from { opacity: 1; transform: translate(-50%, -50%); }
            to { opacity: 0; transform: translate(-50%, -40%); }
        } */
    </style>
</head>
<body>

    <div id="elim-popup">
        <div class="column left-column">
            <div id="elim-placement"></div>
            <img id="elim-logo" src="" alt="Team Logo">
        </div>
        <div class="column center-column">
            <div id="elim-name"></div>
            <div class="elim-status">ELIMINATED</div>
        </div>
        <div class="column right-column">
            <div id="elim-kills"></div>
            <div class="kills-label">KILLS</div>
        </div>
    </div>
    
<script>
    // --- Configuration ---
    // üî• FIX: Using root-relative path to find the file at http://localhost:5000/live_scoreboard.json
    const API_URL = '/live_scoreboard.json'; 
    const defaultLogo = "/assets/default-team-logo.jpg"; // Your default logo
    const POPUP_DURATION = 6000; // 6 seconds
    const POPUP_TRANSITION = 500; // 0.5 seconds
    const POLLING_INTERVAL = 1000; // 1 second

    // --- Global State ---
    let prevElimOrder = [];
    let prevMatchId = null;
    const popupQueue = [];
    let isShowingPopup = false;
    let currentPopupTimeout = null;
    // Tracks the ID of the last match whose 2nd place team was queued
    let lastProcessedFinishedMatchId = null;

    // --- DOM Elements ---
    let popup, logo, name, place, kills;

    // --- Utility Function ---
    function getOrdinal(n) {
        if (typeof n !== 'number') return 'N/A';
        const s = ["th", "st", "nd", "rd"];
        const v = n % 100;
        return n + (s[(v - 20) % 10] || s[v] || s[0]);
    }

    /**
     * üî• NEW: Specifically checks the 'matches' array for the 2nd place team
     * of the most recently finished match.
     */
    function checkFinalElimination(data) {
        const completedMatches = data.matches || [];
        if (completedMatches.length === 0) return;

        const finishedMatch = completedMatches[completedMatches.length - 1];

        // Ensure match is finished and we haven't already processed it
        if (!finishedMatch || finishedMatch.status !== 'finished' || finishedMatch.id === lastProcessedFinishedMatchId) {
            return;
        }

        const eliminationOrder = finishedMatch.eliminationOrder;
        
        // 2nd place team is the last one in the eliminationOrder array
        if (eliminationOrder && eliminationOrder.length > 0) {
            const secondPlaceTeamName = eliminationOrder[eliminationOrder.length - 1];
            const secondPlaceTeam = Object.values(finishedMatch.teams).find(
                team => team.name === secondPlaceTeamName
            );

            if (secondPlaceTeam) {
                // Check if already queued (e.g., by live elim logic)
                const isAlreadyQueued = popupQueue.some(item => 
                    item.name === secondPlaceTeamName && item.placement === 2
                );

                if (!isAlreadyQueued) {
                    const popupData = {
                        name: secondPlaceTeam.name,
                        logo: secondPlaceTeam.logo || defaultLogo,
                        placement: 2, // Explicitly 2nd place
                        kills: secondPlaceTeam.kills || 0
                    };
                    
                    console.log(`üî• Final elimination queued: ${popupData.name} (2nd place from finished match ID: ${finishedMatch.id})`);
                    popupQueue.push(popupData);
                    lastProcessedFinishedMatchId = finishedMatch.id; // Mark as processed
                    processPopupQueue();
                }
            }
        }
    }

    /**
     * Main data fetching and processing function, based on your original file.
     */
    async function fetchData() {
        let data;
        try {
            const response = await fetch(API_URL);
            if (!response.ok) {
                console.error(`HTTP error! status: ${response.status} (URL: ${API_URL})`);
                return;
            }
            try {
                data = await response.json();
            } catch (jsonError) {
                console.error("CRITICAL: Failed to parse JSON. File is malformed.", jsonError);
                return; // Stop execution for this cycle
            }

        } catch (fetchError) {
            console.error('Network error fetching data:', fetchError);
            return; // Stop execution for this cycle
        }

        const matchStatus = data.match_state?.status || 'idle';
        const currentMatchId = data.current_match?.id || null;
        const currentElimOrder = data.current_match?.eliminationOrder || [];
        const teams = data.current_match?.teams || {};

        // ----------------------------------------
        // üî• CRITICAL MATCH TRANSITION LOGIC
        // ----------------------------------------
        if (currentMatchId !== prevMatchId) {
            
            // CASE 1: A new match is starting (ID is new and NOT null)
            if (currentMatchId !== null) {
                console.log(`\n========================================\nüî• NEW LIVE MATCH DETECTED: ${currentMatchId}\n========================================`);
                prevElimOrder = [];
                prevMatchId = currentMatchId;
                
                // Hard reset
                if (popupQueue.length > 0) {
                     console.log(`‚ö†Ô∏è Forcing queue reset and clearing ${popupQueue.length} remaining eliminations.`);
                }
                popupQueue.length = 0; // Clear queue
                if (currentPopupTimeout) {
                    clearTimeout(currentPopupTimeout);
                    currentPopupTimeout = null;
                }
                isShowingPopup = false;
                if (popup) popup.style.display = 'none';

            } 
            // CASE 2: The match just finished (ID changed from X to null)
            else if (prevMatchId !== null) {
                 console.log(`Match ${prevMatchId} finished (ID: null). Retaining queue to finish processing.`);
                 // We DO NOT reset prevMatchId or the queue here.
                 // We allow the queue to drain and for checkFinalElimination to run.
            }
        }
        
        // CASE 3: We are idle (null) and the queue is finally empty
        if (currentMatchId === null && popupQueue.length === 0 && !isShowingPopup && prevMatchId !== null) {
             console.log(`Queue empty after IDLE. Resetting prevMatchId from ${prevMatchId} to null.`);
             prevMatchId = null;
             prevElimOrder = [];
        }

        // Process live eliminations (from your original file's logic)
        if (Object.keys(teams).length > 0 && currentElimOrder.length > prevElimOrder.length) {
            const findTeamByName = (name) => {
                return Object.values(teams).find(team => 
                    team.name.trim().toLowerCase() === name.trim().toLowerCase()
                );
            };

            const eliminationsToProcess = currentElimOrder.slice(prevElimOrder.length);
            
            if (eliminationsToProcess.length > 0) {
                console.log(`üî• ${eliminationsToProcess.length} NEW LIVE ELIMINATION(S):`, eliminationsToProcess);
                
                eliminationsToProcess.forEach((teamName) => {
                    const team = findTeamByName(teamName);

                    if (team) {
                        const totalTeams = Object.keys(teams).length;
                        const elimIndex = currentElimOrder.indexOf(teamName);
                        const placement = totalTeams - elimIndex;
                        
                        // Don't queue 2nd place here; let checkFinalElimination handle it
                        if (placement > 2) { 
                            const popupData = {
                                name: team.name,
                                logo: team.logo || defaultLogo,
                                placement: placement,
                                kills: team.kills || 0
                            };
                            
                            console.log(`üìã Queuing: ${team.name} - ${getOrdinal(placement)} place, ${team.kills || 0} kills`);
                            popupQueue.push(popupData);
                        }
                    } else {
                        console.warn(`‚ö†Ô∏è Team ${teamName} not found in teams object`);
                    }
                });

                prevElimOrder = [...currentElimOrder];
                if (!isShowingPopup) {
                    processPopupQueue();
                }
            }
        }

        // Always check for the 2nd place team using the finished match data
        checkFinalElimination(data);
    }

function processPopupQueue() {
    if (isShowingPopup || popupQueue.length === 0) return;
    if (!logo || !name || !place || !kills) return;

    isShowingPopup = true;
    const teamData = popupQueue.shift();

    logo.src = teamData.logo;
    logo.onerror = () => (logo.src = defaultLogo);
    name.textContent = teamData.name;
    place.textContent = getOrdinal(teamData.placement);
    kills.textContent = teamData.kills;

    // --- Fade In ---
    popup.style.display = 'flex';
    requestAnimationFrame(() => popup.classList.add('show'));

    // --- Wait, then Fade Out ---
    currentPopupTimeout = setTimeout(() => {
        popup.classList.remove('show');

        // Wait for fade-out animation to finish before hiding it
        setTimeout(() => {
            popup.style.display = 'none';
            isShowingPopup = false;
            currentPopupTimeout = null;
            if (popupQueue.length > 0) processPopupQueue();
        }, POPUP_TRANSITION);
    }, POPUP_DURATION);
}

    document.addEventListener('DOMContentLoaded', () => {
        // Initialize DOM elements using your original file's IDs
        popup = document.getElementById('elim-popup');
        logo = document.getElementById('elim-logo');
        name = document.getElementById('elim-name');
        place = document.getElementById('elim-placement');
        kills = document.getElementById('elim-kills');

        // Safety check for the critical elements
        if (!popup || !logo || !name || !place || !kills) {
            console.error("FATAL ERROR: One or more critical DOM elements could not be found. Please ensure your HTML contains elements with IDs: 'elim-popup', 'elim-logo', 'elim-name', 'elim-placement', and 'elim-kills'.");
            return;
        }
        
        console.log('üéÆ Overlay script loaded. Starting polling...');
        fetchData(); // Initial fetch
        setInterval(fetchData, POLLING_INTERVAL);
    });
</script>

</body>
</html>